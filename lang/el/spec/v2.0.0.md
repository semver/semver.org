---
title: Semantic Versioning 2.0.0
language: el
---

# Σημασιολογική Δημιουργία Εκδόσεων 2.0.0 (Semantic Versioning)


Περίληψη
--------

Δοθέντος ενός αριθμού έκδοσης ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ (MAJOR.MINOR.PATCH), αυξήστε την:

1. ΚΥΡΙΑ έκδοση, όταν κάνετε ασύμβατες αλλαγές στο API
1. ΔΕΥΤΕΡΕΥΟΥΣΑ έκδοση, όταν προσθέτετε λειτουργικότητα με τρόπο συμβατό προς τα πίσω
1. ΔΙΟΡΘΩΤΙΚΗ έκδοση, όταν κάνετε επιδιορθώσεις σφαλμάτων με τρόπο συμβατό προς τα πίσω

Πρόσθετες ετικέτες για προ-κυκλοφορία και μεταδεδομένα χτισίματος, είναι διαθέσιμα ως επεκτάσεις
στην μορφή ΚΥΡΙΑ.ΔΕΥΤΕΡΕΥΟΥΣΑ.ΔΙΟΡΘΩΣΗ.

Εισαγωγή
--------

Στον κόσμο της διαχείρισης λογισμικού υπάρχει ένα διαβόητο μέρος που ονομάζεται 
"κόλαση εξαρτήσεων". Όσο περισσότερο μεγαλώνει το σύστημά σας και όσο περισσότερα
πακέτα ενσωματώνετε στο λογισμικό σας, τόσο πιο πιθανό είναι να βρεθείτε μια μέρα
σ' αυτή τη θέση απόγνωσης.

Σε συστήματα με πολλές εξαρτήσεις, η κυκλοφορία νέων εκδόσεων πακέτων μπορεί να γίνει 
πολύ γρήγορα ένας εφιάλτης. Αν οι προδιαγραφές της εξάρτησης είναι πολύ αυστηρές, είστε
σε κίνδυνο κλειδώματος έκδοσης (η αδυναμία αναβάθμισης ενός πακέτου χωρίς να πρέπει να
κυκλοφορήσουν νέες εκδόσεις από κάθε εξαρτώμενο πακέτο). Αν οι εξαρτήσεις ορίζονται πολύ
χαλαρά, αναπόφευκτα θα δαγκωθείτε από την ανηθικότητα έκδοσης (υποθέτοντας συμβατότητα 
με περισσότερες μελλοντικές εκδόσεις απ' ότι είναι λογικό). Η κόλαση εξαρτήσεων είναι εκεί
που το κλείδωμα έκδοσης ή/και η ανηθικότητα έκδοσης, σας αποτρέπουν από το να προωθήσετε
εύκολα και με ασφάλεια το εγχείρημά σας.

Ως μια λύση σ' αυτό το πρόβλημα, προτείνουμε ένα απλό σετ κανόνων και
απαιτήσεων που υπαγορεύουν πως οι αριθμοί εκδόσεων καθορίζονται και αυξάνονται.
Αυτοί οι κανόνες βασίζονται, αλλά δεν περιορίζονται απαραίτητα, σε προϋπάρχουσες
διαδεδομένες κοινές πρακτικές σε χρήση τόσο σε κλειστό όσο και σε λογισμικό
ανοιχτού κώδικα. Για να λειτουργήσει αυτό το σύστημα, πρώτα πρέπει να δηλώσετε
ένα δημόσιο API. Αυτό μπορεί να αποτελείται από τεκμηρίωση ή να επιβάλεται από
τον κώδικα από μόνο του. Όπως και να 'χει είναι σημαντικό αυτό το API να είναι
ξεκάθαρο και συγκεκριμένο. Μόλις ταυτοποιήσετε το δημόσιο API, κοινοποιείτε τις
αλλαγές σ' αυτό με συγκεκριμένες αυξήσεις στον αριθμό έκδοσης. Σκεφτείτε μία
έκδοση της μορφής X.Y.Z (Κύρια.Δευτερεύουσα.Διόρθωση). Διορθώσεις σφαλμάτων που
δεν επηρεάζουν το API αυξάνουν την έκδοση διόρθωσης, προσθήκες/αλλαγές στο API
οι οποίες είναι συμβατές προς τα πίσω αυξάνουν την δευτερεύουσα έκδοση, και 
αλλαγές ασύμβατες με το API αυξάνουν την κύρια έκδοση.

Ονομάζουμε αυτό το σύστημα «Σημασιολογική δημιουργία εκδόσεων».
Με αυτό το σχήμα, οι αριθμοί εκδόσεων και ο τρόπος που αλλάζουν, εκφράζουν
κάποιο νόημα σχετικά με τον υποκείμενο κώδικα και το τι έχει τροποποιηθεί
από την μία έκδοση στην επόμενη.


Προδιαγραφή της Σημασιολογικής Δημιουργίας Εκδόσεων (SemVer)
------------------------------------------------------------

Οι λέξεις κλειδιά «ΠΡΕΠΕΙ» (MUST), «ΔΕΝ ΠΡΕΠΕΙ» (MUST NOT), «ΑΠΑΙΤΕΙΤΑΙ» (REQUIRED),
«ΠΡΕΠΕΙ» (SHALL), «ΔΕΝ ΠΡΕΠΕΙ» (SHALL NOT), «ΣΥΝΙΣΤΆΤΑΙ» (SHOULD), «ΔΕΝ ΣΥΝΙΣΤΆΤΑΙ»
(SHOULD NOT), «ΣΥΝΙΣΤΆΤΑΙ» (RECOMMENDED), «ΜΠΟΡΕΙ» (MAY), και «ΠΡΟΑΙΡΕΤΙΚΑ» (OPTIONAL)
σε αυτό το έγγραφο, πρέπει να ερμηνεύονται όπως περιγράφεται στο
[RFC 2119](https://tools.ietf.org/html/rfc2119).

1. Λογισμικό που χρησιμοποιεί Σημασιολογική δημιουργία εκδόσεων ΠΡΕΠΕΙ να δηλώνει
ένα δημόσιο API. Αυτό το API μπορεί να δηλωθεί στον ίδιο τον κώδικα του ή να υπάρχει
αποκλειστικά στην τεκμηρίωση. Όπως και αν γίνει, ΣΥΝΙΣΤΆΤΑΙ να είναι ακριβές και
εμπεριστατωμένο.

1. Ένας φυσιολογικ αριθμός έκδοσης ΠΡΕΠΕΙ να έχει την μορφή X.Y.Z όπου X, Y, και Z
είναι μη-αρνητικοί ακέραιοι, και ΔΕΝ ΠΡΕΠΕΙ να περιέχουν προπορευόμενα μηδενικά.
Το Χ είναι η κύρια έκδοση, το Υ είναι η δευτερεύουσα έκδοση, και το Ζ είναι η
έκδοση διόρθωσης. Κάθε στοιχείο ΠΡΕΠΕΙ να αυξάνεται αριθμητικά.
Για παράδειγμα: 1.9.0 -> 1.10.0 -> 1.11.0.

1. Μόλις ένα πακέτο με έκδοση κυκλοφορήσει, τα περιεχόμενα αυτής της έκδοσης
ΔΕΝ ΠΡΕΠΕΙ να τροποποιηθούν. Κάθε τροποποίηση ΠΡΕΠΕΙ να κυκλοφορεί με νέα έκδοση.

1. Ο αριθμός κύριας έκδοςσης μηδέν (0.y.z) είναι για την αρχική ανάπτυξη.
Οτιδήποτε ΜΠΟΡΕΙ να αλλάξει οποιαδήποτε στιγμή. Το δημόσιο API ΔΕΝ ΣΥΝΙΣΤΆΤΑΙ
να θεωρείται σταθερό.

1. Η έκδοση 1.0.0 ορίζει το δημόσιο API. Ο τρόπος με τον οποίο ο αριθμός έκδοσης
αυξάνεται μετά από κάθε κυκλοφορία, εξαρτάται από αυτό το δημόσιο API και το
πως αλλάζει.

1. Η Διορθωτική έκδοση Z (x.y.Z | x > 0) ΠΡΕΠΕΙ να αυξάνεται μόνο αν εισάγονται
διορθώσεις σφαλμάτων συμβατές προς τα πίσω. Μία διόθρωση σφάλματος ορίζεται
ως μια εσωτερική αλλαγή που διορθώνει μια εσφαλμένη συμπεριφορά.

1. Η Δευτερεύουσα έκδοση Y (x.Y.z | x > 0) ΠΡΕΠΕΙ να αυξάνεται αν μια νέα,
συμβατή προς τα πίσω, λειτουργικότητα, εισάγεται στο δημόσιο API. ΠΡΕΠΕΙ να
αυξάνεται αν κάποια λειτουργικότητα, οποιουδήποτε δημόσιου API, χαρακτηρίζεται
ως καταργημένη. ΜΠΟΡΕΙ να αυξηθεί αν σημαντική νέα λειτουργικότητα ή βελτιώσεις
εισάγονται μαζί με τον ιδιωτικό κώδικα. ΜΠΟΡΕΙ να περιλαμβάνει αλλαγές επιπέδου
διόρθωσης. Η έκδοση διόρθωσης ΠΡΕΠΕΙ να επανέλθει στο 0 όταν μία δευτερεύουσα
έκδοση αυξάνεται.

1. Η Κύρια έκδοση X (X.y.z | X > 0) ΠΡΕΠΕΙ να αυξάνεται αν εισάγονται στο δημόσιο
API οποιεσδήποτε αλλαγές που είναι ασύμβατες προς τα πίσω. ΜΠΟΡΕΙ επίσης να
συμπεριλαμβάνει δευτερεύουσες και διορθωτικές αλλαγές. Οι διορθωτικές και οι
δευτερεύουσες εκδόσεις ΠΡΕΠΕΙ να επανέρχονται στο 0 όταν η κύρια έκδοση αυξάνεται.

1. Μια έκδοση προ-κυκλοφορίας ΜΠΟΡΕΙ να επισημαίνεται επισυνάπτοντας μία παύλα
και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως μετά την έκδοση
διόρθωσης. Τα αναγνωριστικά ΠΡΕΠΕΙ να αποτελούνται μόνο από αλφαριθμητικούς
χαρακτήρες ASCII και παύλες [0-9A-Za-z-]. Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι
κενά. Τα αριθμητικά αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να περιλαμβάνουν προπορευόμενα
μηδενικά. Οι εκδόσεις προ-κυκλοφορίας έχουν χαμηλότερη προτεραιότητα από
την συσχετιζόμενη φυσιολογική έκδοση. Μία έκδοση προ-κυκλοφορίας υποδεικνύει
ότι η έκδοση είναι ασταθής και μπορεί να μην ικανοποιεί τις επιθυμιτές απαιτήσεις
συμβατότητας όπως επισημαίνεται από την συσχετιζόμενη φυσιολογική έκδοση.
Παραδείγματα: 1.0.0-alpha, 1.0.0-alpha.1, 1.0.0-0.3.7,
1.0.0-x.7.z.92, 1.0.0-x-y-z.--.

1. Μεταδεδομένα χτισίματος ΜΠΟΡΕΙ να επισημαίνονται επισυνάπτοντας το σύμβολο
της πρόσθεσης και μία σειρά από αναγνωριστικά διαχωρισμένα με τελεία, αμέσως
μετά την διόρθωση ή την έκδοση προ-κυκλοφορίας. Τα αναγνωριστικά ΠΡΕΠΕΙ να
αποτελούνται μόνο από αλφαριθμητικούς χαρακτήρες ASCII και παύλες [0-9A-Za-z-].
Τα αναγνωριστικά ΔΕΝ ΠΡΕΠΕΙ να είναι κενά. Τα μεταδεδομένα χτισίματος ΠΡΕΠΕΙ να
αγνοούνται όταν αποφασίζεται η προτεραιότητα έκδοσης. Συνεπώς, όταν δύο
εκδόσεις διαφέρουν μόνο στα μεταδεδομένα χτισίματος, τότε έχουν την ίδια
προτεραιότητα. Παραδείγματα: 1.0.0-alpha+001, 1.0.0+20130313144700,
1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3----117B344092BD.

1. Ως προτεραιότητα αναφαίρεται το πως δύο εκδόσεις συγκρίνονται μεταξύ τους
όταν ταξινομούνται.

   1. Η προτεραιότητα ΠΡΕΠΕΙ να υπολογίζεται διαχωρίζοντας την έκδοση στα
      επιμέρους κύρια, δευτερεύοντα, διορθωτικά και προ-κυκλοφορίας
      αναγνωριστικά, με αυτή τη σειρά (Τα μεταδεδομένα χτισίματος δεν 
      λαμβάνονται υπόψη στην προτεραιότητα).
      
   1. Η προτεραιότητα αποφασίζεται από την πρώτη διαφορά όταν συγκρίνεται το
      καθένα από αυτά τα αναγνωριστικά, από αριστερά προς τα δεξιά ως εξής:
      Κύριες, δευτερεύουσες, και διορθωτικές εκδόσεις συγκρίνονται πάντα
      αριθμητικά.
      
      Παράδειγμα: 1.0.0 < 2.0.0 < 2.1.0 < 2.1.1.

   1. Όταν κύρια, δευτερεύουσα και διορθωτική είναι ίσα, η έκδοση 
      προ-κυκλοφορίας έχει χαμηλότερη προτεραιότητα από μία φυσιολογική έκδοση:
      
      Παράδειγμα: 1.0.0-alpha < 1.0.0.

   1. Η προτεραιότητα για δύο εκδόσεις προ-κυκλοφορίας, με ίδια κύρια, 
      δευτερεύουσα, και διορθωτική έκδοση, ΠΡΕΠΕΙ να αποφασίζεται συγκρίνοντας
      κάθε αναγνωριστικό διαχωρισμένο με τελεία, από αριστερά προς δεξιά,
      μέχρι να βρεθεί διαφορά ως εξής:
      
      1. Αναγνωριστικά που αποτελούνται μόνο από ψηφία συγκρίνονται αριθμητικά.

      1. Αναγνωριστικά με γράμματα ή παύλες συγκρίνονται λεξιλογικά με
         σειρά ταξινόμησης ASCII.

      1. Τα αριθμητικά αναγνωριστικά πάντα έχουν χαμηλότερη προτεραιότητα
         από τα μη-αριθμητικά αναγνωριστικά.

      1. Ένα μεγαλύτερο σετ από πεδία προ-κυκλοφορίας έχει υψηλότερη
         προτεραιότητα από ένα μικρότερο σετ, αν όλα τα προηγούμενα
         αναγνωριστικά είναι ίσα.

      Παράδειγμα: 1.0.0-alpha < 1.0.0-alpha.1 < 1.0.0-alpha.beta < 1.0.0-beta < 
      1.0.0-beta.2 < 1.0.0-beta.11 < 1.0.0-rc.1 < 1.0.0.

Γραμματική της Μορφής Μπάκους-Νάουρ για έγκυρες εκδόσεις SemVer
---------------------------------------------------------------
```
<valid semver> ::= <version core>
                 | <version core> "-" <pre-release>
                 | <version core> "+" <build>
                 | <version core> "-" <pre-release> "+" <build>

<version core> ::= <major> "." <minor> "." <patch>

<major> ::= <numeric identifier>

<minor> ::= <numeric identifier>

<patch> ::= <numeric identifier>

<pre-release> ::= <dot-separated pre-release identifiers>

<dot-separated pre-release identifiers> ::= <pre-release identifier>
                                          | <pre-release identifier> "." <dot-separated pre-release identifiers>

<build> ::= <dot-separated build identifiers>

<dot-separated build identifiers> ::= <build identifier>
                                    | <build identifier> "." <dot-separated build identifiers>

<pre-release identifier> ::= <alphanumeric identifier>
                           | <numeric identifier>

<build identifier> ::= <alphanumeric identifier>
                     | <digits>

<alphanumeric identifier> ::= <non-digit>
                            | <non-digit> <identifier characters>
                            | <identifier characters> <non-digit>
                            | <identifier characters> <non-digit> <identifier characters>

<numeric identifier> ::= "0"
                       | <positive digit>
                       | <positive digit> <digits>

<identifier characters> ::= <identifier character>
                          | <identifier character> <identifier characters>

<identifier character> ::= <digit>
                         | <non-digit>

<non-digit> ::= <letter>
              | "-"

<digits> ::= <digit>
           | <digit> <digits>

<digit> ::= "0"
          | <positive digit>

<positive digit> ::= "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"

<letter> ::= "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J"
           | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T"
           | "U" | "V" | "W" | "X" | "Y" | "Z" | "a" | "b" | "c" | "d"
           | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n"
           | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x"
           | "y" | "z"
```

Γιατί να χρησιμοποιήσετε Σημασιολογική Δημιουργία Εκδόσεων;
-----------------------------------------------------------

Αυτή δεν είναι μια νέα ή επαναστατική ιδέα. Στην πραγματικότητα, πιθανά ήδη
κάνετε κάτι κοντινό σ' αυτό. Το πρόβλημα είναι ότι το "κοντινό" δεν είναι 
αρκετά καλό. Χωρίς συμμόρφωση σε κάποια μορφή επίσημης προδιαγραφής, οι
αριθμοί εκδόσεων είναι ουσιαστικά ανώφελοι στην διαχείριση εξαρτήσεων.
Δίνοντας ένα όνομα και ξεκάθαρη ερμηνεία στις παραπάνω ιδέες, γίνεται εύκολο
να κοινοποιήσετε τις προθέσεις σας στους χρήστες του λογισμικού σας.
Μόλις αυτές οι προθέσεις ξεκαθαριστούν, μπορούν τελικά να κατασκευαστούν
ευέλικτες (αλλά όχι πολύ ευέλικτες) προδιαγραφές εξαρτήσεων.

Ένα απλό παράδειγμα θα επιδείξει πως η Σημασιολογική Δημιουργία Εκδόσεων
μπορεί να κάνει την κόλαση εξαρτήσεων ένα πράγμα του παρελθόντος.
Σκεφτείτε μια βιβλιοθήκη που ονομάζεται «Πυροσβεστικό». Αυτή χρειάζεται
ένα πακέτο που χρησιμοποιεί Σημασιολογική Δημιουργία Εκδόσεων και όνομάζεται
«Σκάλα». Κατά την χρονική στιγμή που το Πυροσβεστικό δημιουργείται, η Σκάλα
είναι στην έκδοση 3.1.0. Επειδή το Πυροσβεστικό χρησιμοποιεί κάποια 
λειτουργικότητα που πρωτοεισάχθηκε στην 3.1.0, μπορείτε με ασφάλεια να
ορίσετε την εξάρτηση από την Σκάλα ως μεγαλύτερη ή ίση με 3.1.0
 you can safely specify the Ladder
dependency as greater than or equal to 3.1.0 but less than 4.0.0. Now, when
Ladder version 3.1.1 and 3.2.0 become available, you can release them to your
package management system and know that they will be compatible with existing
dependent software.

As a responsible developer you will, of course, want to verify that any
package upgrades function as advertised. The real world is a messy place;
there's nothing we can do about that but be vigilant. What you can do is let
Semantic Versioning provide you with a sane way to release and upgrade
packages without having to roll new versions of dependent packages, saving you
time and hassle.

If all of this sounds desirable, all you need to do to start using Semantic
Versioning is to declare that you are doing so and then follow the rules. Link
to this website from your README so others know the rules and can benefit from
them.

FAQ
---

### How should I deal with revisions in the 0.y.z initial development phase?

The simplest thing to do is start your initial development release at 0.1.0
and then increment the minor version for each subsequent release.

### How do I know when to release 1.0.0?

If your software is being used in production, it should probably already be
1.0.0. If you have a stable API on which users have come to depend, you should
be 1.0.0. If you're worrying a lot about backwards compatibility, you should
probably already be 1.0.0.

### Doesn't this discourage rapid development and fast iteration?

Major version zero is all about rapid development. If you're changing the API
every day you should either still be in version 0.y.z or on a separate
development branch working on the next major version.

### If even the tiniest backwards incompatible changes to the public API require a major version bump, won't I end up at version 42.0.0 very rapidly?

This is a question of responsible development and foresight. Incompatible
changes should not be introduced lightly to software that has a lot of
dependent code. The cost that must be incurred to upgrade can be significant.
Having to bump major versions to release incompatible changes means you'll
think through the impact of your changes, and evaluate the cost/benefit ratio
involved.

### Documenting the entire public API is too much work!

It is your responsibility as a professional developer to properly document
software that is intended for use by others. Managing software complexity is a
hugely important part of keeping a project efficient, and that's hard to do if
nobody knows how to use your software, or what methods are safe to call. In
the long run, Semantic Versioning, and the insistence on a well defined public
API can keep everyone and everything running smoothly.

### What do I do if I accidentally release a backwards incompatible change as a minor version?

As soon as you realize that you've broken the Semantic Versioning spec, fix
the problem and release a new minor version that corrects the problem and
restores backwards compatibility. Even under this circumstance, it is
unacceptable to modify versioned releases. If it's appropriate,
document the offending version and inform your users of the problem so that
they are aware of the offending version.

### What should I do if I update my own dependencies without changing the public API?

That would be considered compatible since it does not affect the public API.
Software that explicitly depends on the same dependencies as your package
should have their own dependency specifications and the author will notice any
conflicts. Determining whether the change is a patch level or minor level
modification depends on whether you updated your dependencies in order to fix
a bug or introduce new functionality. We would usually expect additional code
for the latter instance, in which case it's obviously a minor level increment.

### What if I inadvertently alter the public API in a way that is not compliant with the version number change (i.e. the code incorrectly introduces a major breaking change in a patch release)?

Use your best judgment. If you have a huge audience that will be drastically
impacted by changing the behavior back to what the public API intended, then
it may be best to perform a major version release, even though the fix could
strictly be considered a patch release. Remember, Semantic Versioning is all
about conveying meaning by how the version number changes. If these changes
are important to your users, use the version number to inform them.

### How should I handle deprecating functionality?

Deprecating existing functionality is a normal part of software development and
is often required to make forward progress. When you deprecate part of your
public API, you should do two things: (1) update your documentation to let
users know about the change, (2) issue a new minor release with the deprecation
in place. Before you completely remove the functionality in a new major release
there should be at least one minor release that contains the deprecation so
that users can smoothly transition to the new API.

### Does SemVer have a size limit on the version string?

No, but use good judgment. A 255 character version string is probably overkill,
for example. Also, specific systems may impose their own limits on the size of
the string.

### Is "v1.2.3" a semantic version?

No, "v1.2.3" is not a semantic version. However, prefixing a semantic version
with a "v" is a common way (in English) to indicate it is a version number.
Abbreviating "version" as "v" is often seen with version control. Example:
`git tag v1.2.3 -m "Release version 1.2.3"`, in which case "v1.2.3" is a tag
name and the semantic version is "1.2.3".

### Is there a suggested regular expression (RegEx) to check a SemVer string?

There are two. One with named groups for those systems that support them
(PCRE [Perl Compatible Regular Expressions, i.e. Perl, PHP and R], Python
and Go).

See: <https://regex101.com/r/Ly7O1x/3/>

```
^(?P<major>0|[1-9]\d*)\.(?P<minor>0|[1-9]\d*)\.(?P<patch>0|[1-9]\d*)(?:-(?P<prerelease>(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+(?P<buildmetadata>[0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

And one with numbered capture groups instead (so cg1 = major, cg2 = minor,
cg3 = patch, cg4 = prerelease and cg5 = buildmetadata) that is compatible
with ECMA Script (JavaScript), PCRE (Perl Compatible Regular Expressions,
i.e. Perl, PHP and R), Python and Go.

See: <https://regex101.com/r/vkijKf/1/>

```
^(0|[1-9]\d*)\.(0|[1-9]\d*)\.(0|[1-9]\d*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$
```

About
-----

The Semantic Versioning specification was originally authored by [Tom
Preston-Werner](https://tom.preston-werner.com), inventor of Gravatar and
cofounder of GitHub.

If you'd like to leave feedback, please [open an issue on
GitHub](https://github.com/semver/semver/issues).

License
-------

[Creative Commons ― CC BY 3.0](https://creativecommons.org/licenses/by/3.0/)

